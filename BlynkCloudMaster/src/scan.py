import sys
import os
import shutil

SourceFileLists = []
PostFixOfGenHeaderFile = "_TR.h"
AutoGenFolderName = "genData"
TRACE_NUMBER_STARTS_AT = 100
TRACE_NUMBER_PRV = TRACE_NUMBER_STARTS_AT
TRACE_CBK_STARTS_AT = 0
TRACE_CBK_PRV_INDEX = TRACE_CBK_STARTS_AT
CurrentFileProcessing = None
def main():
    ListofFilesInDir(SourceFileLists)

    # Delete the GenFILE 1st
    try:
        shutil.rmtree(AutoGenFolderName)
    except OSError as error:
        print (error)
        
    # Delete TID file
    try: 
        os.remove("TRACEID.TID")
    except OSError as error:
        print (error)
    
    # Create a dir to store all autogenerated headerfile
    try:
        os.mkdir(AutoGenFolderName)
    except OSError as error:
        print (error)

    # Create a TraceID file to use in trace server
    TraceIDs = open("TRACEID.TID", "w")
    bag_of_words = {}
    while len(SourceFileLists) != 0:
        file = SourceFileLists.pop()
        print ("Processing....." + file)
        headerfile,TRFILE = createHeaderFile(file)
        with open(file) as fp:
            fileLineNumber = 1
            for line in fp:
                saveTraceAsDefines(line, fileLineNumber, TraceIDs, headerfile,TRFILE)
                fileLineNumber += 1
    TraceIDs.close()
    # Process the TraceID file for more accurate data representation
    # processTraceIDFIles()


# This function creates the header file for trace usage
def createHeaderFile(fullPathOfFile):
    global CurrentFileProcessing
    head, tail = os.path.split(fullPathOfFile)
    # Save the complete file name so that i can be output to TID file
    CurrentFileProcessing = tail 
    # Remove the *.c and *.cpp
    if (tail.endswith(".c")):
        tail = tail.replace(".c", "")
    else:
        tail = tail.replace(".cpp", "")
    HeaderFile = tail + PostFixOfGenHeaderFile
    print("ToBE generated HeaderFiles is ... " + HeaderFile)

    # Save the file in gen folder
    genHeaderFile = open(AutoGenFolderName + "/" + HeaderFile, "w+")

    return genHeaderFile,tail


def saveTraceAsDefines(line, fileLineNumber, TraceIDs, header,TRFILE):
    # TRACE_NUMBER_PRV is a serial number/TraceID of text/value this gets incremented every time we reach to
    # TRACE_* function in a file 
    global TRACE_NUMBER_PRV,TRACE_CBK_PRV_INDEX
    line = line.strip()
    words = line.strip().split(' ')
    for word in words:

        # Avoid Commented Code
        if word.startswith('//') | word.startswith('/*') | word.startswith('#'):
            break
        
        # Callback parsing " ABTraceInstallCBK("call test callback",test_callback); "
        if word.startswith('ABTraceInstallCBK('):
            callback_text_info = line.strip().split('(').pop(1).strip().split(",").pop(0)
            callback_name = line.strip().split('(').pop(1).strip().split(",").pop(1).strip().split(')').pop(0)
            ABTraceCBK = "{}`{}`{}`{}\n".format(TRACE_CBK_PRV_INDEX,"CBK",callback_name,callback_text_info[1:-1])
            print (ABTraceCBK)
            TraceIDs.writelines(ABTraceCBK)
            header.writelines("#define "+TRFILE+"_"+fileLineNumber.__str__() +"         "+TRACE_CBK_PRV_INDEX.__str__()+"U"+"\n")
            TRACE_CBK_PRV_INDEX += 1
            pass

        # TraceText Parsing
        if word.startswith('TRACE('):
            msgType = line.strip().split('(').pop(1).strip().split(",").pop(0)
            module = line.strip().split('(').pop(1).strip().split(",").pop(1)
            traceTexts = line.strip().split('(').pop(1).strip().split("\"").pop(1)
            TRACE_TEXT = "{}`{}`{}`{}`{}`{}\n".format(TRACE_NUMBER_PRV,msgType,module, traceTexts, CurrentFileProcessing,fileLineNumber)
            TRACE_TEXT = TRACE_TEXT.replace("\r\n", "")
            TRACE_TEXT = TRACE_TEXT.replace("\n\r", "")
            print (TRACE_TEXT)
            TraceIDs.writelines(TRACE_TEXT)
            header.writelines("#define "+TRFILE+"_"+fileLineNumber.__str__() +"         "+TRACE_NUMBER_PRV.__str__()+"U"+"\n")
            TRACE_NUMBER_PRV +=1


        # TraceValue Parsing
        # Parse the %d for values
        if word.startswith('TRACE_VALUE('):
            msgType = line.strip().split('(').pop(1).strip().split(",").pop(0)
            module = line.strip().split('(').pop(1).strip().split(",").pop(1)
            traceTexts = line.strip().split('(').pop(1).strip().split("\"").pop(1)
            TRACE_VALUE = "{}`{}`{}`{}`{}`{}\n".format(TRACE_NUMBER_PRV,msgType,module, traceTexts,CurrentFileProcessing,fileLineNumber)
            # Remove '\r\n' '\r' '\n' from the string
            TRACE_VALUE = TRACE_VALUE.replace("\r\n", "")
            TRACE_VALUE = TRACE_VALUE.replace("\n\r", "")
            # Remove the Variable name from the output
            # h, s, t = TRACE_VALUE.rpartition("\"")
            # Remove tail 't' and new line '\n' to properly format the output file
            # TRACE_VALUE = h + s + '\n';
            print(TRACE_VALUE)
            TraceIDs.writelines(TRACE_VALUE)
            header.writelines("#define "+TRFILE+"_"+fileLineNumber.__str__() +"         "+TRACE_NUMBER_PRV.__str__()+"U"+"\n")
            TRACE_NUMBER_PRV +=1
            


        # TraceValue Parsing
        # Parse the %d for values    
        if word.startswith('TRACE_VALUE2(') | word.startswith('TRACE_VALUE3(') | word.startswith('TRACE_VALUE4('):
            msgType = line.strip().split('(').pop(1).strip().split(",").pop(0)
            module = line.strip().split('(').pop(1).strip().split(",").pop(1)
            traceTexts = line.strip().split('(').pop(1).strip().split("\"").pop(1)
            TRACE_VALUEn = "{}`{}`{}`{}`{}`{}\n".format(TRACE_NUMBER_PRV,msgType,module, traceTexts,CurrentFileProcessing,fileLineNumber)  # [13:-2] 13 = size of TRACE_VALUEn( And -2 is for removing ");"
            # Remove '\r\n' '\r' '\n' from the string
            TRACE_VALUEn = TRACE_VALUEn.replace("\r\n", "")
            TRACE_VALUEn = TRACE_VALUEn.replace("\n\r", "")
            # Remove the Variable name from the output
            # h, s, t = TRACE_VALUEn.rpartition("\"")
            # Remove tail 't' and new line '\n' to properly format the output file
            # TRACE_VALUEn = h + s + '\n';
            print(TRACE_VALUEn)
            TraceIDs.writelines(TRACE_VALUEn)
            header.writelines("#define " + TRFILE + "_" + fileLineNumber.__str__() + "         " + TRACE_NUMBER_PRV.__str__()+"U"+"\n")
            TRACE_NUMBER_PRV +=1



def processTraceIDFIles():
    print ("_____________________________________")
    word = []
    with open('TRACEID.TID', 'r+') as TraceFile:
        for Tracelines in TraceFile:
            TraceList = Tracelines.strip()
            word.append(TraceList.strip().split('`'))
        for line in word:
            print (line)


# Get the all the source list from the dir
def ListofFilesInDir(sourceFileLists):
    print ("getting list of c files")
    for root, dirs, files in os.walk("."):
        for file in files:
            if file.endswith(".cpp") or file.endswith(".c"):
                # print(os.path.join(root, file))
                SourceFileLists.append(os.path.join(root, file))


if __name__ == '__main__':
    main()
